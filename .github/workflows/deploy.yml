name: Deploy to AWS ECR (Laravel â†’ Lambda)

on:
  push:
    branches: ["main"]
  workflow_dispatch:

jobs:
  deploy:
    runs-on: ubuntu-latest
    env:
      AWS_ACCOUNT_ID: "148761674610"
      AWS_REGION: "us-east-1" # keep consistent everywhere
      ECR_REPOSITORY: "gorealestateapis" # ECR repo name (not URI)
      LAMBDA_PLATFORM: "linux/amd64" # set linux/arm64 if your Lambda is ARM64
      UPDATE_ENV_VARS: "false" # set "true" if you want CI to own env vars
      API_URL: "https://tzhc1nmz86.execute-api.us-east-1.amazonaws.com/production/api/blogs"
      # LAMBDA name is read from secrets.LAMBDA_NAME

    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Configure AWS Credentials
        uses: aws-actions/configure-aws-credentials@v4
        with:
          aws-access-key-id: ${{ secrets.AWS_ACCESS_KEY_ID }}
          aws-secret-access-key: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
          aws-region: ${{ env.AWS_REGION }}

      - name: Who am I?
        run: |
          aws sts get-caller-identity
          echo "Region: $AWS_REGION"

      - name: Ensure ECR repository
        run: |
          aws ecr describe-repositories --repository-names "$ECR_REPOSITORY" >/dev/null 2>&1 || \
          aws ecr create-repository --repository-name "$ECR_REPOSITORY" >/dev/null
          ECR_REGISTRY="${AWS_ACCOUNT_ID}.dkr.ecr.${AWS_REGION}.amazonaws.com"
          ECR_REPOSITORY_URI="${ECR_REGISTRY}/${ECR_REPOSITORY}"
          echo "ECR_REGISTRY=$ECR_REGISTRY" >> $GITHUB_ENV
          echo "ECR_REPOSITORY_URI=$ECR_REPOSITORY_URI" >> $GITHUB_ENV

      - name: Log in to Amazon ECR
        run: |
          aws ecr get-login-password --region "$AWS_REGION" | \
          docker login --username AWS --password-stdin "$ECR_REGISTRY"

      - name: Set up Docker Buildx
        uses: docker/setup-buildx-action@v3

      - name: Build and tag Docker image
        run: |
          IMAGE_TAG_SHA="${ECR_REPOSITORY_URI}:${{ github.sha }}"
          IMAGE_TAG_LATEST="${ECR_REPOSITORY_URI}:latest"
          docker buildx build \
            --platform "${LAMBDA_PLATFORM}" \
            -t "$IMAGE_TAG_SHA" \
            -t "$IMAGE_TAG_LATEST" \
            . \
            --load
          echo "IMAGE_TAG_SHA=$IMAGE_TAG_SHA" >> $GITHUB_ENV
          echo "IMAGE_TAG_LATEST=$IMAGE_TAG_LATEST" >> $GITHUB_ENV

      - name: Push Docker image to ECR
        run: |
          docker push "$IMAGE_TAG_SHA"
          docker push "$IMAGE_TAG_LATEST"

      # Optional: keep Lambda env vars in sync (flip UPDATE_ENV_VARS to "true" to enable)
      - name: Update Lambda environment (optional)
        if: ${{ env.UPDATE_ENV_VARS == 'true' }}
        run: |
          aws lambda update-function-configuration \
            --function-name "${{ secrets.LAMBDA_NAME }}" \
            --environment "Variables={
              APP_ENV=production,
              APP_DEBUG=false,
              LOG_CHANNEL=stderr,
              LOG_LEVEL=error,
              APP_STORAGE=/tmp,
              CACHE_STORE=file,
              SESSION_DRIVER=cookie,
              QUEUE_CONNECTION=sync,
              FILESYSTEM_DISK=s3,
              DB_CONNECTION=mysql,
              DB_HOST=${{ secrets.DB_HOST }},
              DB_PORT=3306,
              DB_DATABASE=${{ secrets.DB_DATABASE }},
              DB_USERNAME=${{ secrets.DB_USERNAME }},
              DB_PASSWORD=${{ secrets.DB_PASSWORD }},
              APP_KEY=base64:QZNUjQCEjc7Tbc3qqp48NRNBD+JHpCmBbtoUYDcIMUY=
            }" >/dev/null
          echo "Lambda environment updated."

      - name: Update Lambda to new container image
        run: |
          aws lambda update-function-code \
            --function-name "${{ secrets.LAMBDA_NAME }}" \
            --image-uri "$IMAGE_TAG_SHA" >/dev/null
          aws lambda wait function-updated \
            --function-name "${{ secrets.LAMBDA_NAME }}"
          echo "Lambda now points to image:"
          aws lambda get-function \
            --function-name "${{ secrets.LAMBDA_NAME }}" \
            --query 'Code.ImageUri' --output text

      - name: Install jq (for JSON assertions)
        run: sudo apt-get update && sudo apt-get install -y jq

      - name: Tail Lambda logs for 2 minutes (post-deploy)
        if: always() # still run even if previous step failed, helpful for debugging
        run: |
          timeout 120 aws logs tail "/aws/lambda/${{ secrets.LAMBDA_NAME }}" \
            --region "${{ env.AWS_REGION }}" \
            --since 10m \
            --follow \
            --format short

      # ---------- Extra diagnostics on failure ----------
      - name: Show recent Lambda logs on failure (detailed)
        if: failure()
        run: |
          aws logs tail "/aws/lambda/${{ secrets.LAMBDA_NAME }}" \
            --region "${{ env.AWS_REGION }}" \
            --since 30m \
            --format detailed

          echo "Last invocation's tail logs via Lambda API:"
          aws lambda invoke \
            --region "${{ env.AWS_REGION }}" \
            --function-name "${{ secrets.LAMBDA_NAME }}" \
            --log-type Tail \
            /tmp/out.json --query 'LogResult' --output text | base64 --decode || true
          echo
          echo "Payload from last invoke:"
          cat /tmp/out.json || true
