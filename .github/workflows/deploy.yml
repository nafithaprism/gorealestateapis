name: Deploy to EC2 via SSM (Laravel)

on:
  push:
    branches: ["main"]
  workflow_dispatch:

env:
  AWS_REGION: us-east-1

jobs:
  deploy:
    runs-on: ubuntu-latest
    permissions:
      contents: read

    steps:
      - name: Checkout (optional)
        uses: actions/checkout@v4
        with:
          fetch-depth: 1

      - name: Configure AWS credentials
        uses: aws-actions/configure-aws-credentials@v4
        with:
          aws-access-key-id: ${{ secrets.AWS_ACCESS_KEY_ID }}
          aws-secret-access-key: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
          aws-region: ${{ env.AWS_REGION }}

      - name: Ensure jq is installed
        run: |
          if ! command -v jq >/dev/null 2>&1; then
            sudo apt-get update -y
            sudo apt-get install -y jq
          fi

      - name: Deploy via SSM (git pull on EC2)
        env:
          RAW_INSTANCE_ID: ${{ secrets.EC2_INSTANCE_ID }}
        run: |
          # Trim any whitespace from the secret (common copy/paste issue)
          INSTANCE_ID="$(echo -n "$RAW_INSTANCE_ID" | tr -d '[:space:]')"

          # 1) Define the remote script (single string, no quoting headaches)
          read -r -d '' SCRIPT <<'EOS'
          set -euo pipefail

          # --- settings for your server/app ---
          APP_DIR="/var/www/gorealestateapis"
          BRANCH="main"
          PHP_FPM="php8.3-fpm"
          NGINX="nginx"
          # ------------------------------------

          cd "$APP_DIR" || { echo "App dir not found: $APP_DIR"; exit 1; }

          # Put app in maintenance (safe deploy)
          php artisan down || true

          # Update code from Git (repo must already be cloned here)
          if [ ! -d .git ]; then
            echo "❌ Not a git repo at $APP_DIR"; exit 1
          fi
          git fetch --all
          git reset --hard "origin/$BRANCH"

          # Install PHP deps
          if ! command -v composer >/dev/null 2>&1; then
            echo "❌ Composer not found on server"; exit 1
          fi
          composer install --no-dev --prefer-dist --no-interaction --optimize-autoloader

          # Laravel housekeeping
          chmod -R ug+rw storage bootstrap/cache || true
          php artisan migrate --force || true
          php artisan cache:clear || true
          php artisan config:cache || true
          php artisan route:cache || true
          php artisan view:cache || true
          php artisan queue:restart || true

          # Reload services (if present)
          systemctl is-active --quiet "$PHP_FPM" && sudo systemctl reload "$PHP_FPM" || true
          systemctl is-active --quiet "$NGINX"   && sudo systemctl reload "$NGINX"   || true

          # Back online
          php artisan up || true

          echo "✅ Deploy complete on $(hostname) at $(date -u +"%Y-%m-%dT%H:%M:%SZ")"
          EOS

          # 2) Build parameters JSON file (exact AWS CLI format)
          jq -n --arg s "$SCRIPT" '{commands: [$s]}' > /tmp/params.json

          # 3) Call SSM and capture CommandId
          CMD_JSON=$(aws ssm send-command \
            --instance-ids "$INSTANCE_ID" \
            --document-name "AWS-RunShellScript" \
            --comment "Deploy $GITHUB_SHA" \
            --parameters file:///tmp/params.json)

          COMMAND_ID=$(echo "$CMD_JSON" | jq -r '.Command.CommandId')
          echo "CommandId: $COMMAND_ID"

          # 4) (Optional) Wait for completion and print output
          # Poll until the invocation is done
          for i in {1..60}; do
            STATUS=$(aws ssm list-command-invocations \
              --command-id "$COMMAND_ID" \
              --details \
              | jq -r '.CommandInvocations[0].Status // empty')
            [[ -n "$STATUS" ]] || { sleep 2; continue; }
            echo "SSM status: $STATUS"
            if [[ "$STATUS" == "Success" || "$STATUS" == "Cancelled" || "$STATUS" == "TimedOut" || "$STATUS" == "Failed" ]]; then
              break
            fi
            sleep 3
          done

          # Show the output (stdout/stderr) if available
          aws ssm list-command-invocations \
            --command-id "$COMMAND_ID" \
            --details \
            | jq -r '
                .CommandInvocations[0].CommandPlugins[0] as $p
                | "---- STDOUT ----\n" + ($p.Output // "") + "\n---- STDERR ----\n" + ($p.StandardErrorUrl // "")
              '
